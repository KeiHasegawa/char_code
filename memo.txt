(*1) Shift-JIS の文字コード
(*2) C++ スタイルのコメント
(*3) Perl のコメント
(*4) C スタイルのコメント
(*5) 文字列リテラル
(*6) 文字リテラル

(*1) Shift-JIS の文字コード

http://charset.7jp.net/sjis.html

これによると 2 バイトの Shift-JIS の文字は

[\x81-\x9f\xe0-\xfc][\x40-\x7e\x80-\xfc]
                     ^^^^^^^^^
                     (*A)
		     
と正規表現で表すことができる. (*A) は 0x5c = \
を含むので厄介な問題を引き起こすことがある.

半角カナは

[\xa1-\xdf]

と正規表現で表すことができる.

(*2) C++ スタイルのコメント

// This is a C++ style comment.

上は普通のコメント. 改行をエスケープする '\' があった場合

// This is a comment \
followed by a new line.

followed から始まる行もコメントと解釈される. => test000.cpp

'\' = 0x5c なので Shift-JIS で半角カナを書いている限りは大丈夫そうだが,
2 バイト目が 0x5c の文字, 例えば, '能', '表' などがある場合
コメントの続きと解釈されてしまうことがある.
=> test001.cpp, test002.cpp

g++ で試してみると test001.cpp, test002.cpp は残念ながらエラーになってしまう.

% g++ -E test001.cpp

のように試してみると, 期待しない形式でコメントが削除されていることが分かる.

% g++ -E test001.cpp -finput-charset=sjis
期待した形でコメントを解釈してくれている
% g++ -c test001.cpp -finput-charset=sjis
OK

しかし, (*5) の test007.c や test038.c の例も参照.

cygwin% hcpp.exe test001.cpp

としてみるとこれは一応正しく動作しているようだ. これは Windows 版ビルドの
hcpp.exe で試した結果であるが,

linux% hcpp.exe test001.cpp

としてみると, 期待しない形式でコメントが削除されていた.

linux% hcpp.exe -e sjis test001.cpp

ならば期待通り動作している.

一応 Visual Studio 2019 のコンパイラでも試してみたが, 正しく動作している.

もう一つ別の例を見てみる. test035.cpp は g++ により warning を受ける.

% g++ -c test035.cpp

test035.cpp のファイルの最後にさらにもう一つ改行が加われば warning が
消えるという奇妙な現象が, 初見の人にとっては起こる. しかし, '能' の 2 バイト目が
0x5c = \ であることを知っていれば, これはもはや驚くべきことではないかもしれない.

プログラムテキストではないが, 例えば, Windows スタイルのパス名は
'\' が区切りになっているから,

C:\Windows\System32\Boot\winload.exe
     (1)      (2)    (3)

に対して 3 を返すような函数を作成する場合

C:\Users\hasegawa\代表的\機能性\doc.txt
    (1)    (2)      (3)   (4)

に対して 4 を正しく返すには文字コードを意識する必要がある.

EUC には幸い 2 バイト目が 0x5c の文字はない.

JIS(ISO-2022-JP) には '怒', '倍' などがあるが JIS は漢字の開始, ASCII の開
始等の規則があるのでこのような問題が起こることはない.

例えば test005.c であるが,
(JIS でコーディングされているのでコピーペーストではなくてファイルをダウンロード
する必要がある)

// 怒
int anger;

は

2f 2f 20    1b  24 42 45 5c 1b  28 42 0a
/  /  (空白) ESC $  B   怒   ESC (  B  改行

ここで ESC $ B は漢字の開始, ESC ( B は ASCII の開始である.
5c の後に ASCII の開始があるので Shift-JIS のような問題は起こらない.

UTF-8 にはどのバイトにも 0x5c が出現することはないのでこの問題は起こらない.

UTF-16LE や UTF-16BE はどうか. これはそもそもコンパイラが対応している
かどうかがまず問題である. => test023.c
test023.c は UTF-16LE でコーディングされている. (やはりコピーペーストではなくて
ファイルをダウンロードする必要がある)

% gcc test023.c

このエラーを見る限り gcc は対応していない.

仮に UTF-16LE もしくは UTF-16BE 対応のコンパイラがあったとするなら 5c は 1 バイト
目にも 2 バイト目にも出現する可能性はあるので特別な対応が必要になる.
と思ったが, そもそも ASCII 文字も 2 バイトで表現するのが UTF-16 なのでむしろ
こういう問題は起こりにくくなるのだろう.

ざっと見たところ馴染みのない文字ばかりではある. 例えば test024.c はコメントの最後
の文字が

0x77 0x5c

である.
Visual Studio 2019 のコンパイラで試してみた. test023.c も test024.c も
問題なくコンパイルできている. UTF-16LE に対応していたのだ.

// のコメントの終わりは改行で 0x0a = '\n' や \n\r = 0x0a0d
が該当する.

Shift-JIS の 2 バイト目が 0x0a や 0x0d であることはないのでこのような問題は起こらない.
仮に Shift-JIS の '騙' の 2 バイト目が 0x0a ならば

// 騙int a = 1;

などが誤って解釈されることになるがそういうことはないということである.
同様に EUC, JIS の 2 バイト目も 0x0a や 0x0d であることはないのでこのような問
題は起こらない.

コメントの始まりとなる '/' = 0x2f が 2 バイト目となることは Shift-JIS, EUC
ではないが JIS では 1 バイト目でもありうる. しかし, // 形式のコメントの
中に // が表れても単純に無視されるだけである.
文字列リテラル中ならどうか.

const char* p = "痛ｯｯ";

ｯ は JIS コードの 0x2f = '/' である. しかし文字列中の // はコメントの始まりでは
ないからこの場合も問題にはならない.

(*3) Perl のコメント

C++ のコメントにあったような '\' で改行をエスケープすることはないので

# This is a comment\
followed by a new line.

これはエラーになる. => test006.pl
C++ のコメントのような問題は起こらない.

(*4) C スタイルのコメント

/*
 * This is a C style comment.
 */

上は普通のコメント. コメントの中にコメントは書けない. => test003.c

/*
 *  /* ... */ <- ここまでがコメントと解釈されるから
 */

しかし /* だけを書くのは問題にはならない

/*
 *      /*  <- OK
 */

2 バイト目が 0x2a = '*' の文字は Shift-JIS にはないので
コメントの終わりだと解釈されることはない. つまり
'騙' の 2 バイト目が仮に '*' だった場合

/*
 *  /* ... 騙/
 */

これは問題になるが, そういうことは起こらないということだ.

2 バイト目が 0x2f の文字はどうか. これも幸い Shift-JIS にはないので

/*
 *
 *    騙/      */

が誤って解釈されることはない. 上は仮に'騙' の 2 バイト目が '/' だった場合
を考えたものであるが, これは適切な例ではなかった. C スタイルコメント中の
// は単純に無視されるからだ.

EUC は 2 バイト目が 0x2a や 0x2f の文字はないので問題は起こらない.

JIS(ISO-2022-JP) は問題が起こる可能性は多いにある.

/*
 * 条件をﾁｪｯｸする
 */

JIS でコーディングしたもの => test021.c
(JIS でコーディングされているのでコピーペーストではなくてファイルをダウンロード
する必要がある)
コメントの終端を判定するのに注意が必要である.
ｪ = 0x2a = '*'
ｯ = 0x2f = '/'

なのでここをコメントの終わりと受け取ってしまう可能性はある.

% gcc test021.c

とするとそうなっていると気付くだろう.

% gcc test021.c -finput-charset=jis
cc1: error: conversion from jis to UTF-8 not supported by iconv
対応していないとのことだった.

一応 Visual Studio 2019 のコンパイラでも試してみた. やはり問題の箇所をコメントの終わ
りと受け取っているようである.

参考までに test022.c は test021.c を生成するプログラムである.

(*5) 文字列リテラル

以下は普通の文字列リテラル

printf("hello world\n");

文字列リテラルの中にダブルクォーテーションを含ませたい場合は
'\' でエスケープする.

printf("\"abcdef\"\n");

例によって Shift-JIS の 2 バイト目の文字が '\' = 0x5c の場合, 例え
ば, '能', '表' などは注意が必要になる.

=> test007.c, test008.c

test007.c は運良く(?) コンパイルエラーになった.

% gcc test007.c

これは '\' = 0x5c の次に '"' が続いたので文字列リテラルの終端をコンパイラ
が検出できなかったためである.

% gcc test007.c -finput-charset=sjis

ではどうか. どうやら標準ヘッダでエラーが出ている.

% gcc test036.c -finput-charset=sjis
% ./a.exe > b

エラーは回避できたが b は残念ながら期待値とは異なる.

% gcc test036.c -finput-charset=sjis -fexec-charset=sjis
なんだか bug report を送れというメッセージが出る.

% gcc test037.c -finput-charset=sjis
% ./a.exe > b
b は期待値と合致!

-finput-charset=sjis オプションありなら test037.c が期待通り動作
するのに test036.c が動作しないのは... 全く訳が分からない.

少し横道にそれるようだが, -finput-charset=sjis オプションで標準ヘッダ
でエラーになる原因を調査してみた. エラーを再現させる簡単な環境 => test038.c

% gcc -c test038.c
OK
% gcc -c test038.c -finput-charset=sjis
エラーになる
% gcc -c test038.c -finput-charset=sjis -E
期待しない形になっている.

この現象だけから推測すると... 行末の \ を無視するというのが -finput-charset=sjis
オプションの効果の 1 つということになる. このバグを駆使して巧妙なサンプルを作成する
には時間がもったいない. それにこれは横道にそれただけなのだ.

test007.c ではだめだが, プログラマ自身が文字コードを配列に指定することは
可能である. 例えば

% gcc test011.c
% ./a.exe

これは期待通り動作して, "機能" と表示する.

test008.c はプログラム実行時文字化けを引き起こしている.
test008.c も test012.c のようにすれば文字化けを回避することはできる.

同じ問題は Perl でも起こる => test009.pl, test010.pl

JIS(ISO-2022-JP) も文字列リテラルに指定した場合特別な対処が必要になるだろ
う. => test018.c, test019.c
(JIS でコーディングされているのでコピーペーストではなくてファイルをダウンロード
する必要がある)

例えば test018.c の最初の文字列リテラルは

22 1b  24 42 45 5c 1b   28 42 22
"  ESC $  B    怒   ESC  ( B  "

である. ESC $ B は漢字の開始, ESC ( B は ASCII の開始である.
gcc で test018.c をコンパイルすると \033 のエスケープシーケンスなど
ないという warning が出力される. 033 = 0x1b でこれは ASCII の開始である.
当然ながら gcc では test018.c は期待通り動作しない.

test018.c の文字列の値を配列に格納することで期待する結果が得られる. => test020.c

もうひとつ考慮する必要があることは 2 バイト文字にダブルクォーテーションが入っている
場合である. " = 0x22 だが Shift-JIS の 2 バイト目が 0x22 になることはない.

EUC の場合も 2 バイト目が 0x22 になることはない.

問題は JIS で
1 バイト目が 0x22 のものには, 例えば, '♪' => test025.c
2 バイト目が 0x22 のものには, 例えば, 'あ' => test026.c
1 バイト目も 2 バイト目も 0x22 のものは '□' => test027.c
である.

gcc はいずれも JIS 文字列中の 0x22 をダブルクォーテーションとして解釈している.
test025.c がエラーになる理由は

  "文字列"v

のように解釈されているからで「ここには ')' が期待されるという」エラーメッセージ
を出力する. せっかくなので ')' を読み込ませるために '〒' を指定してみた => test028.c
が, 驚くような結果にはならず, エラーメッセージが分かりにくいということだけである.

test026.c もエラーメッセージが分かりにくいということだけである.

test027.c はコンパイルエラーにはならない. これは運悪くダブルクォーテーションが
連なり文字列が連結されたためである. 勿論だが生成されたプログラムが期待通り
動作することはない.

JIS を駆使すれば驚くような結果となるプログラムを書くことができるだろう. => test029.c

% gcc test029.c
% ./a.exe
helloworld
%

参考までに test029.c を作りだすのに test030.c を使った. test029.c は
JIS の文字列リテラルを正しく処理できるコンパイラでは, 指定された文字列を
表示することになる.

JIS コードの半角カナ '｢' = 0x22 である. なのでこれを使った
test031.c なども問題になる.

  puts("｢ｺﾝﾆﾁﾊ｣");


(*6) 文字リテラル

あまり書くことがないが C, C++ にはワイド文字リテラルなるものがある. => test013.c

  wchar_t wc = L'a';

ワイド文字リテラルにシングルクォーテーションを指定したい場合は
通常の文字リテラルと同様に \ でエスケープする必要がある. => test014.c

  wchar_t wc = L'\'';

例によって Shift-JIS の 2 バイト目の文字が '\' = 0x5c の場合, 例え
ば, '能', '表' などは注意が必要になる. => test015.c, test016.c

2 バイト目が '\' = 0x5c でない文字ならば問題にならないかと思ったが, 残念ながら
gcc ではエラーになる. => test017.c

マルチバイト文字はあきらめて JIS の半角カナについて考えてみる.

JIS では 0x27 = ' = ｧ でこれを文字リテラルに含められると文字リテラル
の終端を正しく解釈できない => test032.c

JIS では 0x5c = \ = ﾜ だからこれで 0x27 = ' をエスケープしてみた => test033.c

% gcc test033.c

文字定数が型に対して長いという警告が出ている. あまり面白い結果にはならな
かったが, 結局のところ注意が必要ということである.

ところで JIS コードを正しく解釈できるコンパイラが test032.c に対して
生成したプログラムの結果はどうあるべきだろうか. 普通であれば

ｧ

のように JIS コードを出力することではある. 一方, 文字リテラル 'ｧ' に
対して 0x1b, 0x28, 0x49, 0x27 を保持する必要があって, これは
1 バイトでは表現できない.

test034.c は, 上で言及した, test032.c の実行結果の期待値を生み出す
プログラムのソースである. ここまで考えると何が正しいのかは(私が)釈然とは
しない.

'ｧ';    // エラー. 1 バイトで表現できない.
L'ｧ';   // OK. リテラルの値は 0x1b284927 か 0x2749281b のいずれか

とするのが妥当かとも思える.
