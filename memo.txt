(*1) Shift-JIS の文字コード
(*2) C++ スタイルのコメント
(*3) Perl のコメント
(*4) C スタイルのコメント
(*5) 文字列リテラル


(*1) Shift-JIS の文字コード

http://charset.7jp.net/sjis.html

これによると

2 バイトコードの始まりの可能性があるのは
0x80 ... 0xa0
0xe0 ... 0xff

半角カナが
0xa1 ... 0xdf
に割り当てられていることが分かる.

(*2) C++ スタイルのコメント

// This is a C++ style comment.

上は普通のコメント. 改行をエスケープする '\' があった場合

// This is a comment \
followed by a new line.

followed から始まる行もコメントと解釈される. => test000.cpp

'\' = 0x5c なので半角カナを書いている限りは大丈夫そうだが,
2 バイト目が 0x5c の文字, 例えば, '能', '表' などがある場合
コメントの続きと解釈されてしまう.
=> test001.cpp, test002.cpp

プログラムテキストではないが, 例えば, Windows スタイルのパス名は
'\' が区切りになっているから,

C:\Windows\System32\Boot\winload.exe
     (1)      (2)    (3)

に対して 3 を返すような函数を作成する場合

C:\Users\hasegawa\代表的\機能性\doc.txt
    (1)    (2)      (3)   (4)

に対して 4 を正しく返すには文字コードを意識する必要がある.
EUC には幸い 2 バイト目が 0x5c の文字はない.
JIS には '怒', '倍' などがあるが JIS は
漢字の開始, ASCII の開始の規則があるのでこのような問題が起こることはない.

例えば test005.c であるが

// 怒
int anger;

は

2f 2f 20    1b  24 42 45 5c 1b  28 42 0a
/  /  (空白) ESC $  B   怒   ESC (  B  改行

ここで ESC $ B は漢字の開始, ESC ( B は ASCII の開始である
5c の後に ASCII の開始があるので Shift-JIS のような問題は起こらない.

(*3) Perl のコメント

C++ のコメントにあったような '\' で改行をエスケープすることはないので

# This is a comment\
followed by a new line.

これはエラーになる. => test006.pl
C++ のコメントのような問題は起こらない.

(*4) C スタイルのコメント

/*
 * This is a C style comment.
 */

上は普通のコメント. コメントの中にコメントは書けない. => test003.c

/*
 *  /* ... */ <- ここまでがコメントと解釈されるから
 */

しかし /* だけを書くのは問題にはならない

/*
 *      /*  <- OK
 */

2 バイト目が 0x2a = '*' の文字は Shift-JIS にはないので
コメントの終わりだと解釈されることはない. つまり
'騙' の 2 バイト目が仮に '*' だった場合

/*
 *  /* ... 騙/
 */

これは問題になるが, そういうことは起こらないということだ.

2 バイト目が 0x2f の文字はどうか. これも幸い Shift-JIS にはないので

/*
 *
 *    騙/      */

が誤って解釈されることはない. 上は仮に'騙' の 2 バイト目が仮に '/' だった場合
を考えたものであるが, これは適切な例ではなかった. C スタイルコメント中の
// は単純に無視されるからだ.

(*5) 文字列リテラル

以下は普通の文字列リテラル

printf("hello world\n");

文字列リテラルの中にダブルクォーテーションを含ませたい場合は
'\' でエスケープする.

printf("\"abcdef\"\n");

例によって Shift-JIS の 2 バイト目の文字が '\' = 0x5c の場合, 例え
ば, '能', '表' などは注意が必要になる.

=> test007.c, test008.c

test007.c は運良く(?) コンパイルエラーになった.

これは '\' = 0x5c の次に '"' が続いたので文字列リテラルの終端をコンパイラ
が検出できなかったためである.

test008.c はプログラム実行時文字化けを引き起こしている.

同じ問題は Perl でも起こる => test009.pl, test010.pl
