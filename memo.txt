(*1) Shift-JIS の文字コード
(*2) C++ スタイルのコメント
(*3) Perl のコメント
(*4) C スタイルのコメント
(*5) 文字列リテラル
(*6) 文字リテラル

(*1) Shift-JIS の文字コード

http://charset.7jp.net/sjis.html

これによると

2 バイトコードの始まりの可能性があるのは
0x80 ... 0xa0
0xe0 ... 0xff

半角カナが
0xa1 ... 0xdf
に割り当てられていることが分かる.

2 バイトコードの 2 バイト目は 0x40 ... 0xfc の可能性がある.

(*2) C++ スタイルのコメント

// This is a C++ style comment.

上は普通のコメント. 改行をエスケープする '\' があった場合

// This is a comment \
followed by a new line.

followed から始まる行もコメントと解釈される. => test000.cpp

'\' = 0x5c なので Shift-JIS で半角カナを書いている限りは大丈夫そうだが,
2 バイト目が 0x5c の文字, 例えば, '能', '表' などがある場合
コメントの続きと解釈されてしまうことがある.
=> test001.cpp, test002.cpp

g++ で試してみると test001.cpp, test002.cpp は残念ながらエラーになってしまう.

% g++ -E test001.cpp

のように試してみると, 期待しない形式でコメントが削除されていることが分かる.

cygwin% hcpp.exe test001.cpp

としてみるとこれは一応正しく動作しているようだ. これは cygwin ビルドの
hcpp.exe で試した結果であるが,

linux% hcpp.exe test001.cpp

としてみると, 期待しない形式でコメントが削除されていた.

linux% hcpp.exe -e sjis test001.cpp

ならば期待通り動作している.

プログラムテキストではないが, 例えば, Windows スタイルのパス名は
'\' が区切りになっているから,

C:\Windows\System32\Boot\winload.exe
     (1)      (2)    (3)

に対して 3 を返すような函数を作成する場合

C:\Users\hasegawa\代表的\機能性\doc.txt
    (1)    (2)      (3)   (4)

に対して 4 を正しく返すには文字コードを意識する必要がある.

EUC には幸い 2 バイト目が 0x5c の文字はない.

JIS(ISO-2022-JP) には '怒', '倍' などがあるが JIS は漢字の開始, ASCII の開
始の規則があるのでこのような問題が起こることはない.

例えば test005.c であるが,
(JIS でコーディングされているのでコピーペーストではなくてファイルをダウンロード
する必要がある)

// 怒
int anger;

は

2f 2f 20    1b  24 42 45 5c 1b  28 42 0a
/  /  (空白) ESC $  B   怒   ESC (  B  改行

ここで ESC $ B は漢字の開始, ESC ( B は ASCII の開始である
5c の後に ASCII の開始があるので Shift-JIS のような問題は起こらない.

UTF-8 にはどのバイトにも 5c が出現することはないので問題は起こらない.

UTF-16LE や UTF-16BE はどうか. これはそもそもコンパイラが対応している
かどうかがまず問題である. => test023.c
test023.c は UTF-16LE でコーディングされている. (やはりコピーペーストではなくて
ファイルをダウンロードする必要がある)

% gcc test023.c

このエラーを見る限り gcc は対応していない.

仮に UTF-16LE もしくは UTF-16BE 対応のコンパイラがあったとするなら 5c は 1 バイト
目にも 2 バイト目にも出現する可能性はあるので特別な対応が必要になる. ざっと見たところ
馴染みのない文字ばかりではある. 例えば test024.c はコメントの最後の文字が

0x77 0x5c

である.

(*3) Perl のコメント

C++ のコメントにあったような '\' で改行をエスケープすることはないので

# This is a comment\
followed by a new line.

これはエラーになる. => test006.pl
C++ のコメントのような問題は起こらない.

(*4) C スタイルのコメント

/*
 * This is a C style comment.
 */

上は普通のコメント. コメントの中にコメントは書けない. => test003.c

/*
 *  /* ... */ <- ここまでがコメントと解釈されるから
 */

しかし /* だけを書くのは問題にはならない

/*
 *      /*  <- OK
 */

2 バイト目が 0x2a = '*' の文字は Shift-JIS にはないので
コメントの終わりだと解釈されることはない. つまり
'騙' の 2 バイト目が仮に '*' だった場合

/*
 *  /* ... 騙/
 */

これは問題になるが, そういうことは起こらないということだ.

2 バイト目が 0x2f の文字はどうか. これも幸い Shift-JIS にはないので

/*
 *
 *    騙/      */

が誤って解釈されることはない. 上は仮に'騙' の 2 バイト目が仮に '/' だった場合
を考えたものであるが, これは適切な例ではなかった. C スタイルコメント中の
// は単純に無視されるからだ.

EUC は 2 バイト目が 0x2a や 0x2f の文字はないので問題は起こらない.

JIS(ISO-2022-JP) は問題が起こる可能性は多いにある.

/*
 * 条件をﾁｪｯｸする
 */

JIS でコーディングしたもの => test021.c
(JIS でコーディングされているのでコピーペーストではなくてファイルをダウンロード
する必要がある)
コメントの終端を判定するのに注意が必要である.
ｪ = 0x2a = '*'
ｯ = 0x2f = '/'

なのでここをコメントの終わりと受け取ってしまう可能性はある.

% gcc test021.c

とするとそうなっていると気付くだろう.
一応 Visual Studio のコンパイラでも試してみた. やはり問題の箇所をコメントの終わ
りと受け取っているようである.

% hcpp.exe test021.c -e iso2022_jp

としてみたがやはり問題の箇所をコメントの終わりと受け取っているようだ.

参考までに test022.c は test021.c を生成するプログラムである.

(*5) 文字列リテラル

以下は普通の文字列リテラル

printf("hello world\n");

文字列リテラルの中にダブルクォーテーションを含ませたい場合は
'\' でエスケープする.

printf("\"abcdef\"\n");

例によって Shift-JIS の 2 バイト目の文字が '\' = 0x5c の場合, 例え
ば, '能', '表' などは注意が必要になる.

=> test007.c, test008.c

test007.c は運良く(?) コンパイルエラーになった.

% gcc test007.c

これは '\' = 0x5c の次に '"' が続いたので文字列リテラルの終端をコンパイラ
が検出できなかったためである.

% hcpp.exe test007.c -o test007.i -I...
% hcc1.exe test007.i -o test007.s

残念ながら hcc1.exe でもエラーになってしまう.

test007.c ではだめだが, プログラマ自身が文字コードを配列に指定することは
可能である. 例えば

% gcc test011.c
% ./a.exe

これは期待通り動作して, "機能" と表示する.

test008.c はプログラム実行時文字化けを引き起こしている.
test008.c も test012.c のようにすれば文字化けを回避することはできる.

同じ問題は Perl でも起こる => test009.pl, test010.pl

JIS(ISO-2022-JP) も文字列リテラルの中ではうまくいかない. => test018.c, test019.c
(JIS でコーディングされているのでコピーペーストではなくてファイルをダウンロード
する必要がある)

例えば test018.c の最初の文字列リテラルは

22 1b  24 42 45 5c 1b   28 42 22
"  ESC $  B    怒   ESC  ( B  "

である. ESC $ B は漢字の開始, ESC ( B は ASCII の開始である.
gcc で test018.c をコンパイルすると \033 のエスケープシーケンスなど
ないという warning が出力される. 033 = 0x1b でこれは ASCII の開始である.

test018.c の文字列の値を配列に格納することで期待する結果が得られる. => test020.c

(*6) 文字リテラル

あまり書くことがないが C, C++ にはワイド文字リテラルものがある. => test013.c

  wchar_t wc = L'a';

ワイド文字リテラルにシングルクォーテーションを指定したい場合は
通常の文字列リテラルと同様に \ でエスケープする必要がある. => test014.c

  wchar_t wc = L'\'';

例によって Shift-JIS の 2 バイト目の文字が '\' = 0x5c の場合, 例え
ば, '能', '表' などは注意が必要になる. => test015.c, test016.c

2 バイト目が '\' = 0x5c でない文字ならば問題にならないかと思ったが, 残念ながら
gcc ではエラーになる. => test017.c
