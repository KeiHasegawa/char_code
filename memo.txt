(*1) Shift-JIS の文字コード
(*2) C++ スタイルのコメント
(*3) Perl のコメント
(*4) C スタイルのコメント
(*5) 文字列リテラル
(*6) 文字リテラル

(*1) Shift-JIS の文字コード

http://charset.7jp.net/sjis.html

これによると

2 バイトコードの始まりの可能性があるのは
0x80 ... 0xa0
0xe0 ... 0xff

半角カナが
0xa1 ... 0xdf
に割り当てられていることが分かる.

2 バイトコードの 2 バイト目は 0x40 ... 0xfc の可能性がある.

(*2) C++ スタイルのコメント

// This is a C++ style comment.

上は普通のコメント. 改行をエスケープする '\' があった場合

// This is a comment \
followed by a new line.

followed から始まる行もコメントと解釈される. => test000.cpp

'\' = 0x5c なので Shift-JIS で半角カナを書いている限りは大丈夫そうだが,
2 バイト目が 0x5c の文字, 例えば, '能', '表' などがある場合
コメントの続きと解釈されてしまうことがある.
=> test001.cpp, test002.cpp

g++ で試してみると test001.cpp, test002.cpp は残念ながらエラーになってしまう.

% g++ -E test001.cpp

のように試してみると, 期待しない形式でコメントが削除されていることが分かる.

cygwin% hcpp.exe test001.cpp

としてみるとこれは一応正しく動作しているようだ. これは cygwin ビルドの
hcpp.exe で試した結果であるが,

linux% hcpp.exe test001.cpp

としてみると, 期待しない形式でコメントが削除されていた.

linux% hcpp.exe -e sjis test001.cpp

ならば期待通り動作している.

プログラムテキストではないが, 例えば, Windows スタイルのパス名は
'\' が区切りになっているから,

C:\Windows\System32\Boot\winload.exe
     (1)      (2)    (3)

に対して 3 を返すような函数を作成する場合

C:\Users\hasegawa\代表的\機能性\doc.txt
    (1)    (2)      (3)   (4)

に対して 4 を正しく返すには文字コードを意識する必要がある.

EUC には幸い 2 バイト目が 0x5c の文字はない.

JIS には '怒', '倍' などがあるが JIS は漢字の開始, ASCII の開始の規則があるので
このような問題が起こることはない.

例えば test005.c であるが

// 怒
int anger;

は

2f 2f 20    1b  24 42 45 5c 1b  28 42 0a
/  /  (空白) ESC $  B   怒   ESC (  B  改行

ここで ESC $ B は漢字の開始, ESC ( B は ASCII の開始である
5c の後に ASCII の開始があるので Shift-JIS のような問題は起こらない.

(*3) Perl のコメント

C++ のコメントにあったような '\' で改行をエスケープすることはないので

# This is a comment\
followed by a new line.

これはエラーになる. => test006.pl
C++ のコメントのような問題は起こらない.

(*4) C スタイルのコメント

/*
 * This is a C style comment.
 */

上は普通のコメント. コメントの中にコメントは書けない. => test003.c

/*
 *  /* ... */ <- ここまでがコメントと解釈されるから
 */

しかし /* だけを書くのは問題にはならない

/*
 *      /*  <- OK
 */

2 バイト目が 0x2a = '*' の文字は Shift-JIS にはないので
コメントの終わりだと解釈されることはない. つまり
'騙' の 2 バイト目が仮に '*' だった場合

/*
 *  /* ... 騙/
 */

これは問題になるが, そういうことは起こらないということだ.

2 バイト目が 0x2f の文字はどうか. これも幸い Shift-JIS にはないので

/*
 *
 *    騙/      */

が誤って解釈されることはない. 上は仮に'騙' の 2 バイト目が仮に '/' だった場合
を考えたものであるが, これは適切な例ではなかった. C スタイルコメント中の
// は単純に無視されるからだ.

EUC は 2 バイト目が 0x2a や 0x2f の文字はないので問題は起こらない.

JIS は問題が起こる可能性は多いにある.

/*
 * 条件をﾁｪｯｸする
 */

JIS でコーディングしたもの => test021.c
コメントの終端を判定するのに注意が必要である.
ｪ = 0x2a = '*'
ｯ = 0x2f = '/'

なのでここをコメントの終わりと受け取ってしまう可能性はある.

(*5) 文字列リテラル

以下は普通の文字列リテラル

printf("hello world\n");

文字列リテラルの中にダブルクォーテーションを含ませたい場合は
'\' でエスケープする.

printf("\"abcdef\"\n");

例によって Shift-JIS の 2 バイト目の文字が '\' = 0x5c の場合, 例え
ば, '能', '表' などは注意が必要になる.

=> test007.c, test008.c

test007.c は運良く(?) コンパイルエラーになった.

% gcc test007.c

これは '\' = 0x5c の次に '"' が続いたので文字列リテラルの終端をコンパイラ
が検出できなかったためである.

% hcpp.exe test007.c -o test007.i -I...
% hcc1.exe test007.i -o test007.s

残念ながら hcc1.exe でもエラーになってしまう.

% gcc test011.c
% ./a.exe

これは期待通り動作する.

test008.c はプログラム実行時文字化けを引き起こしている.
test008.c も test012.c のようにすれば文字化けを回避することはできる.

同じ問題は Perl でも起こる => test009.pl, test010.pl

C++ スタイルのコメントでは問題は起こらなかった JIS コードだが文字列リテラルの
中ではうまくいかない. => test018.c, test019.c
例えば test018.c の最初の文字列リテラルは

22 1b  24 42 45 5c 1b   28 42 22
"  ESC $  B    怒   ESC  ( B  "

である. ESC $ B は漢字の開始, ESC ( B は ASCII の開始である.
gcc で test018.c をコンパイルすると \033 のエスケープシーケンスなど
ないという warning が出力される. 033 = 0x1b でこれは ASCII の開始である.

test018.c の文字列の値を配列に格納することで期待する結果が得られる. => test020.c

(*6) 文字リテラル

あまり書くことがないが C, C++ にはワイド文字リテラルものがある. => test013.c

ワイド文字リテラルにシングルクォーテーションを指定したい場合は
通常の文字列リテラルと同様に \ でエスケープする必要がある. => test014.c

例によって Shift-JIS の 2 バイト目の文字が '\' = 0x5c の場合, 例え
ば, '能', '表' などは注意が必要になる. => test015.c, test016.c

2 バイト目が '\' = 0x5c でない文字ならば問題にならないかと思ったが, 残念ながら
gcc ではエラーになる. => test017.c
